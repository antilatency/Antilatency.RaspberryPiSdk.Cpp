//Generated by AntilatencyApiGenerator
#pragma once
#ifndef ANTILATENCY_INTERFACE_CONTRACT_EXCEPTIONS_ENABLED
#define ANTILATENCY_INTERFACE_CONTRACT_EXCEPTIONS_ENABLED
#endif
#include <Antilatency.InterfaceContract.h>
#include <Antilatency.InterfaceContract.Memory.h>
#include <cstdint>
#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable: 4946)
#pragma warning(disable: 4265)
#endif
namespace Antilatency {
	namespace IpNetwork {
		/// <summary>UTF8 32 bytes length string representation</summary>
		struct RawString32 {
			Antilatency::InterfaceContract::Memory::Memory32 data;
		};
	} //namespace IpNetwork
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/// <summary>Standard error codes</summary>
		enum class ErrorType : uint8_t {
			None = 0x0,
			Unknown = 0x1,
			AdnLibraryLoad = 0x2,
			AltTrackingLibraryLoad = 0x3,
			TrackingNodeNotFound = 0x4,
			TrackingNodeNotReady = 0x5,
			CotaskConstructor = 0x6,
			TrackingTaskRestartMessage = 0x7,
			TrakingCotaskConstructFailed = 0x8,
			AltEnvironmentArbitrary2D = 0x9,
			ReadTagProperty = 0xA,
			ReadSerialNumber = 0xB,
			StartTrackingTaskFailed = 0xC,
			GetTrackerStateFailed = 0xD,
			SetupGpio = 0xE
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	inline const char* enumToString(const Antilatency::IpNetwork::ErrorType& x) {
		switch (x) {
			case Antilatency::IpNetwork::ErrorType::None: return "None";
			case Antilatency::IpNetwork::ErrorType::Unknown: return "Unknown";
			case Antilatency::IpNetwork::ErrorType::AdnLibraryLoad: return "AdnLibraryLoad";
			case Antilatency::IpNetwork::ErrorType::AltTrackingLibraryLoad: return "AltTrackingLibraryLoad";
			case Antilatency::IpNetwork::ErrorType::TrackingNodeNotFound: return "TrackingNodeNotFound";
			case Antilatency::IpNetwork::ErrorType::TrackingNodeNotReady: return "TrackingNodeNotReady";
			case Antilatency::IpNetwork::ErrorType::CotaskConstructor: return "CotaskConstructor";
			case Antilatency::IpNetwork::ErrorType::TrackingTaskRestartMessage: return "TrackingTaskRestartMessage";
			case Antilatency::IpNetwork::ErrorType::TrakingCotaskConstructFailed: return "TrakingCotaskConstructFailed";
			case Antilatency::IpNetwork::ErrorType::AltEnvironmentArbitrary2D: return "AltEnvironmentArbitrary2D";
			case Antilatency::IpNetwork::ErrorType::ReadTagProperty: return "ReadTagProperty";
			case Antilatency::IpNetwork::ErrorType::ReadSerialNumber: return "ReadSerialNumber";
			case Antilatency::IpNetwork::ErrorType::StartTrackingTaskFailed: return "StartTrackingTaskFailed";
			case Antilatency::IpNetwork::ErrorType::GetTrackerStateFailed: return "GetTrackerStateFailed";
			case Antilatency::IpNetwork::ErrorType::SetupGpio: return "SetupGpio";
		}
		return "";
	}
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/// <summary>Fixed size structure for tracking information</summary>
		struct StateMessage {
			Antilatency::IpNetwork::RawString32 rawTag;
			float positionX;
			float positionY;
			float positionZ;
			float rotationX;
			float rotationY;
			float rotationZ;
			float rotationW;
			Antilatency::IpNetwork::ErrorType trackerError;
		};
	} //namespace IpNetwork
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		struct GpioPinState {
			int32_t number;
			int32_t value;
		};
	} //namespace IpNetwork
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/// <summary>CommandName:CommandValue pair interface</summary>
		enum class CommandKey : uint8_t {
			None = 0x0,
			Custom = 0x1,
			SetEnvinromentCode = 0x2,
			SetSendingRate = 0x3
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	inline const char* enumToString(const Antilatency::IpNetwork::CommandKey& x) {
		switch (x) {
			case Antilatency::IpNetwork::CommandKey::None: return "None";
			case Antilatency::IpNetwork::CommandKey::Custom: return "Custom";
			case Antilatency::IpNetwork::CommandKey::SetEnvinromentCode: return "SetEnvinromentCode";
			case Antilatency::IpNetwork::CommandKey::SetSendingRate: return "SetSendingRate";
		}
		return "";
	}
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		std::string id() {
			throw std::logic_error{"Method IDeviceState.id() is not implemented."};
		}
		std::string sessionId() {
			throw std::logic_error{"Method IDeviceState.sessionId() is not implemented."};
		}
		std::string ipAddress() {
			throw std::logic_error{"Method IDeviceState.ipAddress() is not implemented."};
		}
		std::string deviceError() {
			throw std::logic_error{"Method IDeviceState.deviceError() is not implemented."};
		}
		Antilatency::InterfaceContract::LongBool newState() {
			throw std::logic_error{"Method IDeviceState.newState() is not implemented."};
		}
		int64_t packetNumber() {
			throw std::logic_error{"Method IDeviceState.packetNumber() is not implemented."};
		}
		int64_t timeStamp() {
			throw std::logic_error{"Method IDeviceState.timeStamp() is not implemented."};
		}
		int64_t latency() {
			throw std::logic_error{"Method IDeviceState.latency() is not implemented."};
		}
		std::vector<Antilatency::IpNetwork::GpioPinState> gpioState() {
			throw std::logic_error{"Method IDeviceState.gpioState() is not implemented."};
		}
		std::vector<Antilatency::IpNetwork::StateMessage> lastStates() {
			throw std::logic_error{"Method IDeviceState.lastStates() is not implemented."};
		}
		*/
		/// <summary>Network enabled device information</summary>
		struct IDeviceState : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL id(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sessionId(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL ipAddress(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL deviceError(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL newState(Antilatency::InterfaceContract::LongBool& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL packetNumber(int64_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL timeStamp(int64_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL latency(int64_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL gpioState(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL lastStates(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0xcc3466e2,0x1d33,0x4564,{0x87,0x54,0x47,0x6d,0x9d,0x53,0xc3,0xd2}};
				}
			private:
				~VMT() = delete;
			};
			IDeviceState() = default;
			IDeviceState(std::nullptr_t) {}
			explicit IDeviceState(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<IDeviceState, T>::value>::type>
			IDeviceState& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static IDeviceState create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			std::string id() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->id(resultMarshaler));
				return result;
			}
			std::string sessionId() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->sessionId(resultMarshaler));
				return result;
			}
			std::string ipAddress() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->ipAddress(resultMarshaler));
				return result;
			}
			std::string deviceError() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->deviceError(resultMarshaler));
				return result;
			}
			Antilatency::InterfaceContract::LongBool newState() {
				Antilatency::InterfaceContract::LongBool result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->newState(result));
				return result;
			}
			int64_t packetNumber() {
				int64_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->packetNumber(result));
				return result;
			}
			int64_t timeStamp() {
				int64_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->timeStamp(result));
				return result;
			}
			int64_t latency() {
				int64_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->latency(result));
				return result;
			}
			std::vector<Antilatency::IpNetwork::GpioPinState> gpioState() {
				std::vector<Antilatency::IpNetwork::GpioPinState> result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->gpioState(resultMarshaler));
				return result;
			}
			std::vector<Antilatency::IpNetwork::StateMessage> lastStates() {
				std::vector<Antilatency::IpNetwork::StateMessage> result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->lastStates(resultMarshaler));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::IDeviceState, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::IDeviceState::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL id(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->id();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sessionId(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->sessionId();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL ipAddress(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->ipAddress();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL deviceError(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->deviceError();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL newState(Antilatency::InterfaceContract::LongBool& result) {
					try {
						result = this->_object->newState();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL packetNumber(int64_t& result) {
					try {
						result = this->_object->packetNumber();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL timeStamp(int64_t& result) {
					try {
						result = this->_object->timeStamp();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL latency(int64_t& result) {
					try {
						result = this->_object->latency();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL gpioState(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->gpioState();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL lastStates(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->lastStates();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		uint32_t size() {
			throw std::logic_error{"Method IConstDeviceList.size() is not implemented."};
		}
		Antilatency::IpNetwork::IDeviceState get(uint32_t index) {
			throw std::logic_error{"Method IConstDeviceList.get() is not implemented."};
		}
		*/
		/// <summary>All devices in network</summary>
		struct IConstDeviceList : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL size(uint32_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL get(uint32_t index, Antilatency::IpNetwork::IDeviceState& result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0x259db783,0x92f1,0x4f4d,{0xbd,0x35,0x05,0x35,0x54,0x23,0x33,0x2f}};
				}
			private:
				~VMT() = delete;
			};
			IConstDeviceList() = default;
			IConstDeviceList(std::nullptr_t) {}
			explicit IConstDeviceList(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<IConstDeviceList, T>::value>::type>
			IConstDeviceList& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static IConstDeviceList create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			uint32_t size() {
				uint32_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->size(result));
				return result;
			}
			Antilatency::IpNetwork::IDeviceState get(uint32_t index) {
				Antilatency::IpNetwork::IDeviceState result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->get(index, result));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::IConstDeviceList, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::IConstDeviceList::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL size(uint32_t& result) {
					try {
						result = this->_object->size();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL get(uint32_t index, Antilatency::IpNetwork::IDeviceState& result) {
					try {
						result = this->_object->get(index);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		std::string id() {
			throw std::logic_error{"Method ICommandMessage.id() is not implemented."};
		}
		std::string ipAddress() {
			throw std::logic_error{"Method ICommandMessage.ipAddress() is not implemented."};
		}
		std::string error() {
			throw std::logic_error{"Method ICommandMessage.error() is not implemented."};
		}
		int64_t timeStamp() {
			throw std::logic_error{"Method ICommandMessage.timeStamp() is not implemented."};
		}
		Antilatency::IpNetwork::CommandKey key() {
			throw std::logic_error{"Method ICommandMessage.key() is not implemented."};
		}
		std::string value() {
			throw std::logic_error{"Method ICommandMessage.value() is not implemented."};
		}
		*/
		/// <summary>CommandName:CommandValue pair interface</summary>
		struct ICommandMessage : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL id(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL ipAddress(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL error(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL timeStamp(int64_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL key(Antilatency::IpNetwork::CommandKey& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL value(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0xf413aba1,0x5c2f,0x41f1,{0xb1,0xb0,0x73,0x09,0x67,0x6a,0x6c,0x4a}};
				}
			private:
				~VMT() = delete;
			};
			ICommandMessage() = default;
			ICommandMessage(std::nullptr_t) {}
			explicit ICommandMessage(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<ICommandMessage, T>::value>::type>
			ICommandMessage& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static ICommandMessage create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			std::string id() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->id(resultMarshaler));
				return result;
			}
			std::string ipAddress() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->ipAddress(resultMarshaler));
				return result;
			}
			std::string error() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->error(resultMarshaler));
				return result;
			}
			int64_t timeStamp() {
				int64_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->timeStamp(result));
				return result;
			}
			Antilatency::IpNetwork::CommandKey key() {
				Antilatency::IpNetwork::CommandKey result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->key(result));
				return result;
			}
			std::string value() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->value(resultMarshaler));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::ICommandMessage, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::ICommandMessage::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL id(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->id();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL ipAddress(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->ipAddress();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL error(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->error();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL timeStamp(int64_t& result) {
					try {
						result = this->_object->timeStamp();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL key(Antilatency::IpNetwork::CommandKey& result) {
					try {
						result = this->_object->key();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL value(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->value();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		uint32_t size() {
			throw std::logic_error{"Method IConstCommandList.size() is not implemented."};
		}
		Antilatency::IpNetwork::ICommandMessage get(uint32_t index) {
			throw std::logic_error{"Method IConstCommandList.get() is not implemented."};
		}
		*/
		/// <summary>Command queue</summary>
		struct IConstCommandList : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL size(uint32_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL get(uint32_t index, Antilatency::IpNetwork::ICommandMessage& result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0x2c31f909,0x8b65,0x48b8,{0x83,0x8f,0xe7,0xec,0x38,0x9a,0xaa,0x29}};
				}
			private:
				~VMT() = delete;
			};
			IConstCommandList() = default;
			IConstCommandList(std::nullptr_t) {}
			explicit IConstCommandList(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<IConstCommandList, T>::value>::type>
			IConstCommandList& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static IConstCommandList create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			uint32_t size() {
				uint32_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->size(result));
				return result;
			}
			Antilatency::IpNetwork::ICommandMessage get(uint32_t index) {
				Antilatency::IpNetwork::ICommandMessage result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->get(index, result));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::IConstCommandList, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::IConstCommandList::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL size(uint32_t& result) {
					try {
						result = this->_object->size();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL get(uint32_t index, Antilatency::IpNetwork::ICommandMessage& result) {
					try {
						result = this->_object->get(index);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		void sendStateMessages(const std::vector<Antilatency::IpNetwork::StateMessage>& stateMessages, const std::vector<Antilatency::IpNetwork::GpioPinState>& gpioPins, const std::string& deviceError) {
			throw std::logic_error{"Method INetworkServer.sendStateMessages() is not implemented."};
		}
		void sendCommand(Antilatency::IpNetwork::CommandKey command, const std::string& value) {
			throw std::logic_error{"Method INetworkServer.sendCommand() is not implemented."};
		}
		void startMessageListening() {
			throw std::logic_error{"Method INetworkServer.startMessageListening() is not implemented."};
		}
		void startCommandListening() {
			throw std::logic_error{"Method INetworkServer.startCommandListening() is not implemented."};
		}
		Antilatency::IpNetwork::IConstDeviceList getDeviceList() {
			throw std::logic_error{"Method INetworkServer.getDeviceList() is not implemented."};
		}
		Antilatency::IpNetwork::IConstCommandList getCommands() {
			throw std::logic_error{"Method INetworkServer.getCommands() is not implemented."};
		}
		*/
		/// <summary>Network exchange implementer</summary>
		struct INetworkServer : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sendStateMessages(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate stateMessages, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate gpioPins, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate deviceError) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sendCommand(Antilatency::IpNetwork::CommandKey command, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate value) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL startMessageListening() = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL startCommandListening() = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getDeviceList(Antilatency::IpNetwork::IConstDeviceList& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getCommands(Antilatency::IpNetwork::IConstCommandList& result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0x95416322,0x9e28,0x49dc,{0x88,0x50,0x16,0x65,0xab,0x4b,0x08,0x1e}};
				}
			private:
				~VMT() = delete;
			};
			INetworkServer() = default;
			INetworkServer(std::nullptr_t) {}
			explicit INetworkServer(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<INetworkServer, T>::value>::type>
			INetworkServer& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static INetworkServer create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			void sendStateMessages(const std::vector<Antilatency::IpNetwork::StateMessage>& stateMessages, const std::vector<Antilatency::IpNetwork::GpioPinState>& gpioPins, const std::string& deviceError) {
				auto stateMessagesMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(stateMessages);
				auto gpioPinsMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(gpioPins);
				auto deviceErrorMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(deviceError);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->sendStateMessages(stateMessagesMarshaler, gpioPinsMarshaler, deviceErrorMarshaler));
			}
			void sendCommand(Antilatency::IpNetwork::CommandKey command, const std::string& value) {
				auto valueMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(value);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->sendCommand(command, valueMarshaler));
			}
			void startMessageListening() {
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->startMessageListening());
			}
			void startCommandListening() {
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->startCommandListening());
			}
			Antilatency::IpNetwork::IConstDeviceList getDeviceList() {
				Antilatency::IpNetwork::IConstDeviceList result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getDeviceList(result));
				return result;
			}
			Antilatency::IpNetwork::IConstCommandList getCommands() {
				Antilatency::IpNetwork::IConstCommandList result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getCommands(result));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::INetworkServer, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::INetworkServer::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sendStateMessages(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate stateMessages, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate gpioPins, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate deviceError) {
					try {
						this->_object->sendStateMessages(stateMessages, gpioPins, deviceError);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL sendCommand(Antilatency::IpNetwork::CommandKey command, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate value) {
					try {
						this->_object->sendCommand(command, value);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL startMessageListening() {
					try {
						this->_object->startMessageListening();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL startCommandListening() {
					try {
						this->_object->startCommandListening();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getDeviceList(Antilatency::IpNetwork::IConstDeviceList& result) {
					try {
						result = this->_object->getDeviceList();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getCommands(Antilatency::IpNetwork::IConstCommandList& result) {
					try {
						result = this->_object->getCommands();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

namespace Antilatency {
	namespace IpNetwork {
		/* copy and paste this to implementer
		Antilatency::IpNetwork::INetworkServer getNetworkServer(const std::string& serverId, const std::string& ifaceAddress, const std::string& targetAddress, int32_t trackingPort, int32_t commandPort) {
			throw std::logic_error{"Method ILibrary.getNetworkServer() is not implemented."};
		}
		int64_t getCurrentTime() {
			throw std::logic_error{"Method ILibrary.getCurrentTime() is not implemented."};
		}
		std::string getTagFromRawTag(Antilatency::IpNetwork::RawString32 rawString) {
			throw std::logic_error{"Method ILibrary.getTagFromRawTag() is not implemented."};
		}
		Antilatency::IpNetwork::RawString32 getRawTagFromString(const std::string& tag) {
			throw std::logic_error{"Method ILibrary.getRawTagFromString() is not implemented."};
		}
		std::string getVersion() {
			throw std::logic_error{"Method ILibrary.getVersion() is not implemented."};
		}
		*/
		/// <summary>Main library interface</summary>
		struct ILibrary : Antilatency::InterfaceContract::IInterface {
			struct VMT : Antilatency::InterfaceContract::IInterface::VMT {
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getNetworkServer(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate serverId, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate ifaceAddress, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate targetAddress, int32_t trackingPort, int32_t commandPort, Antilatency::IpNetwork::INetworkServer& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getCurrentTime(int64_t& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getTagFromRawTag(Antilatency::IpNetwork::RawString32 rawString, Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getRawTagFromString(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate tag, Antilatency::IpNetwork::RawString32& result) = 0;
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getVersion(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) = 0;
				static constexpr Antilatency::InterfaceContract::InterfaceID ID() {
					return Antilatency::InterfaceContract::InterfaceID{0x96b0c448,0x6ae2,0x4361,{0xaa,0x16,0xa6,0x70,0x03,0x3d,0x64,0x4a}};
				}
			private:
				~VMT() = delete;
			};
			ILibrary() = default;
			ILibrary(std::nullptr_t) {}
			explicit ILibrary(VMT* pointer) : Antilatency::InterfaceContract::IInterface(pointer) {}
			template<typename T, typename = typename std::enable_if<std::is_base_of<ILibrary, T>::value>::type>
			ILibrary& operator = (const T& other) {
			    Antilatency::InterfaceContract::IInterface::operator=(other);
			    return *this;
			}
			template<class Implementer, class ... TArgs>
			static ILibrary create(TArgs&&... args) {
			    return *new Implementer(std::forward<TArgs>(args)...);
			}
			void attach(VMT* other) ANTILATENCY_NOEXCEPT {
			    Antilatency::InterfaceContract::IInterface::attach(other);
			}
			VMT* detach() ANTILATENCY_NOEXCEPT {
			    return reinterpret_cast<VMT*>(Antilatency::InterfaceContract::IInterface::detach());
			}
			Antilatency::IpNetwork::INetworkServer getNetworkServer(const std::string& serverId, const std::string& ifaceAddress, const std::string& targetAddress, int32_t trackingPort, int32_t commandPort) {
				Antilatency::IpNetwork::INetworkServer result;
				auto serverIdMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(serverId);
				auto ifaceAddressMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(ifaceAddress);
				auto targetAddressMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(targetAddress);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getNetworkServer(serverIdMarshaler, ifaceAddressMarshaler, targetAddressMarshaler, trackingPort, commandPort, result));
				return result;
			}
			int64_t getCurrentTime() {
				int64_t result;
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getCurrentTime(result));
				return result;
			}
			std::string getTagFromRawTag(Antilatency::IpNetwork::RawString32 rawString) {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getTagFromRawTag(rawString, resultMarshaler));
				return result;
			}
			Antilatency::IpNetwork::RawString32 getRawTagFromString(const std::string& tag) {
				Antilatency::IpNetwork::RawString32 result;
				auto tagMarshaler = Antilatency::InterfaceContract::Details::ArrayInMarshaler::create(tag);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getRawTagFromString(tagMarshaler, result));
				return result;
			}
			std::string getVersion() {
				std::string result;
				auto resultMarshaler = Antilatency::InterfaceContract::Details::ArrayOutMarshaler::create(result);
				handleExceptionCode((reinterpret_cast<VMT*>(this->_object))->getVersion(resultMarshaler));
				return result;
			}
		};
	} //namespace IpNetwork
} //namespace Antilatency
namespace Antilatency {
	namespace InterfaceContract {
		namespace Details {
			template<typename Implementer, typename LifeTimeController>
			struct InterfaceRemap<Antilatency::IpNetwork::ILibrary, Implementer, LifeTimeController> : Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController> {
			public:
			    InterfaceRemap() = default;
			    static bool isInterfaceSupported(const Antilatency::InterfaceContract::InterfaceID& id) {
					if (id == Antilatency::IpNetwork::ILibrary::VMT::ID()) {
						return true;
					}
					return Antilatency::InterfaceContract::Details::InterfaceRemap<Antilatency::InterfaceContract::IInterface, Implementer, LifeTimeController>::isInterfaceSupported(id);
				}
			public:
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getNetworkServer(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate serverId, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate ifaceAddress, Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate targetAddress, int32_t trackingPort, int32_t commandPort, Antilatency::IpNetwork::INetworkServer& result) {
					try {
						result = this->_object->getNetworkServer(serverId, ifaceAddress, targetAddress, trackingPort, commandPort);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getCurrentTime(int64_t& result) {
					try {
						result = this->_object->getCurrentTime();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getTagFromRawTag(Antilatency::IpNetwork::RawString32 rawString, Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->getTagFromRawTag(rawString);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getRawTagFromString(Antilatency::InterfaceContract::Details::ArrayInMarshaler::Intermediate tag, Antilatency::IpNetwork::RawString32& result) {
					try {
						result = this->_object->getRawTagFromString(tag);
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
				virtual Antilatency::InterfaceContract::ExceptionCode ANTILATENCY_INTERFACE_CALL getVersion(Antilatency::InterfaceContract::Details::ArrayOutMarshaler::Intermediate result) {
					try {
						result = this->_object->getVersion();
					}
					catch (...) {
						return Antilatency::InterfaceContract::handleRemapException(this->_object);
					}
					return Antilatency::InterfaceContract::ExceptionCode::Ok;
				}
			};
		} //namespace Details
	} //namespace InterfaceContract
} //namespace Antilatency

/// <summary>Library constants</summary>
namespace Antilatency {
	namespace IpNetwork {
		namespace Constants {
			constexpr int32_t MajorVersion = 1;
			constexpr int32_t MinorVersion = 1;
			constexpr int32_t PatchVersion = 0;
			static constexpr const char* DefaultIfaceAddress = "0.0.0.0";
			static constexpr const char* DefaultTargetAddress = "239.255.111.2";
			constexpr int32_t DefaultTrackingPort = 56789;
			constexpr int32_t DefaultCommandPort = 8889;
		} //namespace Constants
	} //namespace IpNetwork
} //namespace Antilatency


#ifdef _MSC_VER
#pragma warning(pop)
#endif
